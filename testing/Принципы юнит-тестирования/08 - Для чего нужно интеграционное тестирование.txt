- Интеграционным тестом является любой тест, который не является юнит-тестом. Интеграционные тесты проверяют,
как ваша система работает в интеграции с внепроцессными зависимостями.

- Интеграционные тесты покрывают контроллеры; юнит-тесты покрывают алго- ритмы и доменную модель.

- Интеграционные тесты обеспечивают лучшую защиту от багов и устойчивость к рефакторингу; юнит-тесты более просты в
поддержке и дают более быструю обратную связь.

- «Порог» для написания интеграционных тестов выше, чем для юнит-тестов: их эффективность по метрике защиты от багов и
устойчивости к рефакторингу должна быть выше, чем у юнит-тестов, для того чтобы скомпенсировать дополнительную сложность
в поддержке и медленную обратную связь. Пирамида тестирования отражает этот компромисс: большинство тестов должны составлять
быстрые и простые в поддержке юнит-тесты при меньшем количестве медленных и более сложных в поддержке интеграционных тестов,
проверяющих правильность системы в целом.
    • Проверяйте как можно больше пограничных случаев бизнес-сценария юнит-тестами. Используйте интеграционные тесты для
    покрытия одного позитивного пути, а также всех пограничных случаев, которые не могут быть покрыты юнит-тестами.
    • Форма пирамиды тестирования зависит от сложности проекта. Простые про- екты содержат небольшой объем кода в
    доменной модели, а следовательно, могут иметь одинаковое количество юнит- и интеграционных тестов. В наи- более
    тривиальных случаях юнит-тестов может не быть вообще.

- Принцип Fail Fast призывает к быстрому обнаружению ошибок в программе; он является допустимой альтернативой интеграционному тестированию.

- Управляемые зависимости представляют собой внепроцессные зависимости, доступ к которым осуществляется только через ваше
приложение. Взаимодействия с управляемыми зависимостями не видимы извне. Типичный пример — база данных приложения.

- Неуправляемые зависимости — внепроцессные зависимости, доступные для других приложений. Взаимодействия с неуправляемыми
зависимостями видны снаружи. Типичные примеры — сервер SMTP и шина сообщений.

- Взаимодействия с управляемыми зависимостями являются деталями имплементации; взаимодействия с неуправляемыми
зависимостями являются частью наблюдаемого поведения вашей системы.

- Используйте реальные экземпляры управляемых зависимостей в интеграцион- ных тестах; заменяйте неуправляемые зависимости моками.

- Иногда внепроцессная зависимость обладает свойствами как управляемых, так и неуправляемых зависимостей.
Типичный пример — база данных, доступная для других приложений. Наблюдаемую часть такой базы следует интерпретировать
как неуправляемую зависимость; заменяйте ее моками в тестах. Рассматривайте остальную часть зависимости как управляемую —
проверяйте ее итоговое состояние, а не взаимодействия с ней.

- Интеграционный тест должен пройти через все уровни, работающие с управляемой зависимостью. В примере с базой данных
это означает проверку состояния базы данных независимо от данных, используемых во входных параметрах.

- Интерфейсы с одной реализацией не являются абстракциями и способствуют слабой связности не более чем конкретные классы,
реализующие эти интерфейсы. Попытки предвидеть будущие реализации таких интерфейсов нарушают принцип YAGNI.

- Единственная причина для использования интерфейсов с единственной реали- зацией — возможность использования моков.
Используйте такие интерфейсы только для неуправляемых зависимостей. Используйте конкретные классы для управляемых зависимостей.

- Использование интерфейсов с одной реализацией для внутрипроцессных зависимостей — признак проблем с кодом.
Такие интерфейсы обычно используют для мокирования и проверки взаимодействий между классами предметной области, что
приводит к привязке тестов к деталям имплементации тестируемого кода.

- Выделите явное место для модели предметной области в коде. Четкая граница между классами предметной области и контроллерами
помогает отличать юнит- тесты от интеграционных.

- Лишние уровни абстракции отрицательно влияют на вашу способность понимать код. Постарайтесь свести количество этих уровней к минимуму.
В большинстве бэкенд-систем достаточно всего трех слоев: предметной области, сервисов приложения и инфраструктуры.

- Циклические зависимости увеличивают когнитивную нагрузку при попытках разобраться в коде. Типичный пример — обратный вызов
(когда вызываемая сторона уведомляет вызывающую о результате своей работы). Разорвите цикл введением объекта-значения;
используйте этот объект-значение для возвращения результата от вызываемой стороны к вызывающей.

- Множественные секции действий в тестах оправданны только в том случае, если тест работает с внепроцессными зависимостями,
которые трудно привести в нужное состояние. Никогда не включайте несколько действий в юнит-тест, потому что юнит-тесты не
работают с внепроцессными зависимостями. Многофазные тесты почти всегда принадлежат к категории сквозных.

- Служебное логирование предназначено для персонала службы поддержки и системных администраторов; оно является частью
наблюдаемого поведения приложения. Диагностическое логирование помогает разработчику понять, что происходит внутри
приложения; оно относится к деталям имплементации.

- Так как служебное логирование является бизнес-требованием, это требование следует явно отразить в коде.
Добавьте специальный класс DomainLogger, в ко- тором перечисляются все требования к служебному логированию со стороны бизнеса.

- Относитесь к служебному логированию как к любой другой функциональности, работающей с внепроцессными зависимостями.
Используйте доменные события для отслеживания изменений в доменной модели, преобразовывайте эти события в обращения к
DomainLogger в контроллерах.

- Не тестируйте диагностическое логирование. В отличие от служебного, диагностическое логирование может выполняться
непосредственно в модели предметной области.

- Не злоупотребляйте диагностическим логированием. Избыточное диагностиче- ское логирование загромождает код и снижает
отношение «сигнал/шум» в логах. В идеале диагностическое логирование должно применяться только для необработанных исключений.

- Всегда явно внедряйте все зависимости (включая логеры) — либо через кон- структор, либо через аргументы метода.