- Сложность кода определяется количеством точек принятия решений в коде, как явных (в самом коде),
так и неявных (в библиотеках, используемых кодом).

- Важность кода показывает, насколько он значим для проекта. Сложный код часто обладает высокой важностью и наоборот,
но не в 100 % случаев.

- Тестирование сложного и важного кода дает наибольшую пользу, потому что соответствующие тесты лучше всего защищают от багов.

- Юнит-тесты, покрывающие код с большим количеством коллабораторов, требуют высоких затрат на сопровождение.
Чтобы привести коллабораторы к необходимому состоянию, а затем проверить их состояние или взаимодействия с ними,
придется написать код, занимающий немало места.

- Весь рабочий код можно разделить на четыре типа по сложности или важности для проекта и количеству коллабораторов:
    • модель предметной области и алгоритмы (высокая сложность или важность для проекта, мало коллабораторов)
    обеспечивает наибольшую эффектив- ность юнит-тестов;
    • тривиальный код (низкая сложность или важность для проекта, мало колла- бораторов) вообще не следует тестировать;
    • контроллеры (низкая сложность или важность для проекта, много коллабо- раторов) должны тестироваться
    интеграционными тестами;
    • переусложненный код (высокая сложность или важность для проекта, много коллабораторов) должен разделяться на
    контроллеры и сложный код.

- Чем важнее или сложнее код, тем меньше у него должно быть коллабораторов.

- Паттерн «Простой объект» помогает сделать переусложненный код пригодным для тестирования за счет извлечения
бизнес-логики из этого кода в отдельный класс. В результате оставшийся код становится контроллером — тонкой, простой
оберткой над бизнес-логикой.

- Гексагональные и функциональные архитектуры реализуют паттерн «Простой объект». Гексагональная архитектура требует
разделения бизнес-логики и взаимодействий с внепроцессными зависимостями. Функциональная архитектура отделяет
бизнес-логику от взаимодействий со всеми коллабораторами, не только внепроцессными.

- Бизнес-логику и координацию можно рассматривать в контексте глубины и ши- рины кода. Ваш код может быть либо глубоким
(сложным или важным), либо широким (работающим со многими коллабораторами), но никогда не должен быть и тем и другим.

- Тестируйте предусловия, если они имеют смысл с точки зрения предметной об- ласти; в противном случае тестировать их не следует.

- В том, что касается отделения бизнес-логики от координации, существуют три важных атрибута:
    • тестируемость доменной модели, которая зависит от количества и типа кол- лабораторов в классах предметной области;
    • простота контроллера, зависящая от присутствия точек принятия решений (ветвления) в контроллере;
    • быстродействие, определяемое как количество обращений к внепроцессным зависимостям.

- В любой конкретной ситуации можно достичь только двух из этих трех атрибутов:
    • перемещение всех внешних операций чтения и записи к границам бизнес-операции сохраняет простоту контроллера и
    тестируемость доменной модели, но с потерями для быстродействия;
    • внедрение внепроцессных зависимостей в доменную модель сохраняет быстродействие и простоту контроллера, но с
    потерями для тестируемости доменной модели;
    • разбиение процесса принятия решений на более мелкие шаги помогает с быстродействием и тестируемостью модели
    предметной области, но с потерями для простоты контроллера.

- Разбиение процесса принятия решений на более мелкие шаги — компромисс с оптимальным набором достоинств и недостатков.
Рост сложности контроллера можно преодолеть при помощи следующих двух паттернов:
    • паттерн «CanExecute/Execute» вводит для каждого метода Do() метод CanDo(), успешное выполнение которого становится
    предусловием для Do(). Этот паттерн фактически исключает принятие решений из контроллера, потому что вызов
    Do() без CanDo() невозможен;
    • события предметной области помогают отслеживать важные изменения в модели предметной области, а затем преобразовать
    эти изменения в обращения к внепроцессным зависимостям. Этот паттерн избавляет контроллер от обязанностей по
    отслеживанию изменений.

- Тестировать абстракции проще, чем то, что они абстрагируют. Доменные собы- тия — абстракции для предстоящих обращений
к внепроцессным зависимостям. Изменения в доменных классах — абстракции для предстоящих изменений в базе данных.